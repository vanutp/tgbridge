import re
from dataclasses import dataclass
from pathlib import Path
from textwrap import dedent
from typing import Literal

import yaml
from pydantic import BaseModel

DEFAULT_OPTION_RGX = re.compile(r'(.*?)( \(.*\))?')


class ConfigOption(BaseModel):
    type: str
    required: Literal['true'] | None = None
    default: str
    example: str | None = None
    description: str = ''


class ConfigSpec(BaseModel):
    options: dict[str, ConfigOption]


def load_yml(path: Path):
    return yaml.load(path.read_text(), Loader=yaml.BaseLoader)


CODEGEN_DIR_PATH = Path(__file__).absolute().parent
REPO_ROOT = CODEGEN_DIR_PATH.parent

EN_CONFIG_PATH = CODEGEN_DIR_PATH / 'config' / 'en.yml'
RU_CONFIG_PATH = CODEGEN_DIR_PATH / 'config' / 'ru.yml'

KOTLIN_SCHEMA_PATH = (
    REPO_ROOT / 'common/src/main/kotlin/dev/vanutp/tgbridge/common/models/Config.kt'
)
DOCS_EN_PATH = REPO_ROOT / 'docs/en/reference.md'
DOCS_RU_PATH = REPO_ROOT / 'docs/ru/reference.md'

en_config = ConfigSpec.model_validate(load_yml(EN_CONFIG_PATH))
ru_config = ConfigSpec.model_validate(load_yml(RU_CONFIG_PATH))

if list(en_config.options.keys()) != list(ru_config.options.keys()):
    # TODO: check if required, type, example and default match
    raise ValueError('en and ru config keys don\'t match')


@dataclass
class KotlinField:
    name: str
    type: str
    default: str
    comments: list[str]


@dataclass
class KotlinDataclass:
    name: str
    fields: list[KotlinField]


@dataclass
class DocsSection:
    name: str
    children: dict[str, 'DocsSection | ConfigOption']


def parse_default(default: str) -> tuple[str, str]:
    m = DEFAULT_OPTION_RGX.fullmatch(default)
    if not m:
        raise ValueError(f'Couldn\'t parse default option value {default}')
    return m.group(1), (m.group(2) or '')


class KotlinRenderer:
    classes: dict[str, KotlinDataclass]
    spec: ConfigSpec

    def __init__(self, spec: ConfigSpec):
        self.classes = {}
        self.spec = spec

    def get_or_create_kotlin_cls(self, path: list[str]) -> KotlinDataclass:
        cls_key = '.'.join(path)
        if cls := self.classes.get(cls_key):
            return cls
        cls = KotlinDataclass(
            name=''.join(x.capitalize() for x in path) + 'Config',
            fields=[],
        )

        if path:
            parent = self.get_or_create_kotlin_cls(path[:-1])
            comments = []
            if path == ['general']:
                # Comment at the top of the config
                comments = [
                    'It\'s enough to set botToken and chatId for the plugin to work.',
                    'When your group has topics enabled, you should also set topicId.',
                    'See https://tgbridge.vanutp.dev for more information.',
                ]
            parent_field = KotlinField(
                name=path[-1],
                type=cls.name,
                default=f'{cls.name}()',
                comments=comments,
            )
            parent.fields.append(parent_field)

        self.classes[cls_key] = cls
        return cls

    @staticmethod
    def type_to_kotlin(opt_name: str, schema_type: str) -> str:
        nullable_suffix = ' | null'
        nullable_mark = '?' if schema_type.endswith(nullable_suffix) else ''
        schema_type = schema_type.removesuffix(nullable_suffix)
        kotlin_base_type = {
            'string': 'String',
            'number': 'Int',
            'boolean': 'Boolean',
        }[schema_type]
        if opt_name == 'chatId':
            kotlin_base_type = 'Long'
        return kotlin_base_type + nullable_mark

    def render_field(self, field: KotlinField) -> list[str]:
        rend_field = [f'val {field.name}: {field.type} = {field.default},\n']
        if field.comments:
            rend_lines = []
            for line in field.comments:
                escaped_line = line.replace('\\', '\\\\').replace('"', '\\"')
                rend_lines.append(f'"{escaped_line}",\n')
            rend_comment = [
                '@YamlComment(\n',
                *['    ' + x for x in rend_lines],
                ')\n',
            ]
            rend_field = rend_comment + rend_field
        return rend_field

    def render_class(self, cls: KotlinDataclass) -> str:
        rend_field_lines = []
        for field in cls.fields:
            rend_field_lines.extend(self.render_field(field))
        return (
            '@Serializable\n'
            + f'data class {cls.name}(\n'
            + ''.join('    ' + x for x in rend_field_lines)
            + ')\n'
        )

    def render(self) -> str:
        res = (
            dedent(
                '''
            // Generated by codegen/generate_config.py. Do not modify
            package dev.vanutp.tgbridge.common.models
    
            import com.charleskorn.kaml.YamlComment
            import kotlinx.serialization.Serializable
        '''
            ).strip()
            + '\n'
        )
        for k, opt in self.spec.options.items():
            *path, opt_name = k.split('.')
            cls = self.get_or_create_kotlin_cls(path)
            comments = [x for x in opt.description.splitlines() if x]
            if opt.example:
                example_val, example_help = parse_default(opt.example)
                comments.append(f'Example: {example_val}{example_help}')
            default_val, default_help = parse_default(opt.default)
            if default_help:
                comments.append(f'Default value: {default_val}{default_help}')
            field = KotlinField(
                name=opt_name,
                type=self.type_to_kotlin(opt_name, opt.type),
                default=default_val,
                comments=comments,
            )
            cls.fields.append(field)

        for cls in self.classes.values():
            res += '\n' + self.render_class(cls)

        return res


class DocsRenderer:
    root: DocsSection
    spec: ConfigSpec

    def __init__(self, spec: ConfigSpec):
        self.root = DocsSection(name='Config reference', children={})
        self.spec = spec

    def get_or_create_parent(self, path: list[str]) -> DocsSection:
        if not path:
            return self.root
        parent = self.get_or_create_parent(path[:-1])
        sect_name = path[-1]

        if sect_name in parent.children:
            return parent.children[sect_name]

        sect = DocsSection(
            name=sect_name,
            children={},
        )
        parent.children[sect_name] = sect
        return sect

    def render_opt(self, name: str, opt: ConfigOption, depth: int) -> str:
        res = '#' * depth + f' {name}\n\n'
        res += f'- **Type:** `{opt.type}`\n'
        if opt.required:
            res += '- **Required**\n'
        default_val, default_help = parse_default(opt.default)
        if default_help:
            res += f'- **Default:** `{default_val}`{default_help}\n'
        if opt.example:
            example_val, example_help = parse_default(opt.example)
            res += f'- **Example:** `{example_val}`{example_help}\n'
        if opt.description:
            res += f'\n{opt.description}\n'
        return res

    def render_section(self, section: DocsSection, depth: int = 1) -> str:
        res = '#' * depth + f' {section.name}\n'
        for name, child in section.children.items():
            res += '\n'
            if isinstance(child, DocsSection):
                res += self.render_section(child, depth + 1)
            else:
                res += self.render_opt(name, child, depth + 1)
        return res

    def render(self) -> str:
        res = '<!-- Generated by codegen/generate_config.py. Do not modify-->\n'
        for name, opt in self.spec.options.items():
            *path, opt_name = name.split('.')
            parent = self.get_or_create_parent(path)
            parent.children[opt_name] = opt
        res += self.render_section(self.root)
        return res


KOTLIN_SCHEMA_PATH.write_text(KotlinRenderer(en_config).render())
DOCS_EN_PATH.write_text(DocsRenderer(en_config).render())
DOCS_RU_PATH.write_text(DocsRenderer(ru_config).render())
